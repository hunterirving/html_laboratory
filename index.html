<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Laboratory</title>
    <link rel="stylesheet" href="prism.css">
    <style>
        :root {
            --bg-color: #2d2d2d;
            --text-color: #f8f8f2;
            --editor-bg: #272822;
            --preview-bg: #2d2d2d;
        }


        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: monospace;
            background: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        .editor-pane {
            width: 50%;
            height: 100vh;
            background: var(--preview-bg);
            position: relative;
        }

        .preview-pane {
            width: 50%;
            height: 100vh;
            background: var(--preview-bg);
            position: relative;
        }

        #editor {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 21px;
            padding: 15px;
            overflow: auto;
            background: var(--editor-bg);
            color: var(--text-color);
            tab-size: 4;
            white-space: pre-wrap;
            overflow-x: auto;
            display: block;
            line-height: 1.5;
        }
        
        /* Override Prism background to match our theme */
        #editor.language-html {
            background: var(--editor-bg) !important;
        }

        #editor:empty:before {
            content: attr(data-placeholder);
            color: #666;
        }

        #preview {
            width: 100%;
            height: 100%;
            border: none;
            background: white;
            overflow: auto;
        }

        #editor {
            padding-top: 15px;
        }

        #preview {
            padding-top: 0;
        }

        /* Hide scrollbars until needed */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--editor-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--header-text);
        }
    </style>
</head>
<body>
    <div class="editor-pane">
        <code id="editor" class="language-html" contenteditable="true" spellcheck="false" data-placeholder="Type your HTML, CSS, and JavaScript here..."></code>
    </div>
    
    <div class="preview-pane">
        <iframe id="preview" sandbox="allow-scripts"></iframe>
    </div>

    <script>
        let updateTimer;
        const editor = document.getElementById('editor');
        const preview = document.getElementById('preview');
        const storageKey = 'html-lab-content';

        function updatePreview() {
            const code = editor.textContent;
            const blob = new Blob([code], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            preview.src = url;
            
            // Clean up the previous URL to prevent memory leaks
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }

        function saveToStorage() {
            try {
                localStorage.setItem(storageKey, editor.textContent);
            } catch (e) {
                // Handle localStorage errors silently
                console.warn('Could not save to localStorage:', e);
            }
        }

        function loadFromStorage() {
            try {
                const saved = localStorage.getItem(storageKey);
                if (saved !== null) {
                    editor.textContent = saved;
                    return true;
                }
            } catch (e) {
                // Handle localStorage errors silently
                console.warn('Could not load from localStorage:', e);
            }
            return false;
        }


        // Handle Tab key to insert tab character
        editor.addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return;
                
                const range = selection.getRangeAt(0);
                
                // Get current cursor position in plain text
                const cursorPos = getCaretOffset(editor, range.startContainer, range.startOffset);
                
                // Get the plain text content
                const plainText = editor.textContent;
                
                // Insert tab at cursor position
                const newText = plainText.substring(0, cursorPos) + '\t' + plainText.substring(cursorPos);
                
                // Update the plain text content first
                editor.textContent = newText;
                
                // Store the new content as last highlighted to prevent immediate re-highlighting
                editor.dataset.lastHighlighted = newText;
                
                // Apply syntax highlighting
                const highlighted = Prism.highlight(newText, Prism.languages.html, 'html');
                editor.innerHTML = highlighted;
                
                // Restore cursor position after the tab
                setTimeout(() => {
                    restoreCaretPosition(editor, cursorPos + 1);
                }, 0);
                
                // Trigger input event to update preview
                this.dispatchEvent(new Event('input'));
            }
        });

        // Update preview after 0.5 seconds of no typing
        editor.addEventListener('input', function() {
            clearTimeout(updateTimer);
            updateTimer = setTimeout(updatePreview, 500);
            
            // Save to localStorage on every change
            saveToStorage();
        });

        // Save functionality with Cmd+S
        document.addEventListener('keydown', function(e) {
            if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                e.preventDefault();
                saveFile();
            }
        });

        function saveFile() {
            const code = editor.textContent;
            const blob = new Blob([code], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'index.html';
            a.click();
            
            URL.revokeObjectURL(url);
        }

        // Initialize the editor content and render
        function initialize() {
            // Always try to load from localStorage regardless of refresh type
            loadFromStorage();
            
            // Focus the editor
            editor.focus();
            
            // Initial render
            updatePreview();
        }

        // Initialize when page loads
        initialize();
    </script>
    <script src="prism.js"></script>
    <script>
        // Set Prism to manual mode to control highlighting
        Prism.manual = true;
        
        // Function to apply syntax highlighting
        function applySyntaxHighlighting() {
            // Don't highlight if editor is not focused to avoid disrupting user
            if (document.activeElement !== editor) {
                return;
            }
            
            // Save cursor position before any changes
            const selection = window.getSelection();
            let offset = 0;
            let hasSelection = false;
            
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                offset = getCaretOffset(editor, range.startContainer, range.startOffset);
                hasSelection = true;
            }
            
            // Get the current content
            const code = editor.textContent;
            
            // Only apply highlighting if the content has actually changed
            if (code === editor.dataset.lastHighlighted) {
                return;
            }
            
            // Apply new highlighting
            const highlighted = Prism.highlight(code, Prism.languages.html, 'html');
            
            // Update content with highlighting
            editor.innerHTML = highlighted;
            
            // Store the last highlighted content
            editor.dataset.lastHighlighted = code;
            
            // Restore cursor position
            if (hasSelection) {
                // Use a small timeout to ensure DOM is updated
                setTimeout(() => {
                    restoreCaretPosition(editor, offset);
                }, 0);
            }
        }
        
        // Helper function to get caret offset
        function getCaretOffset(root, node, offset) {
            try {
                let textOffset = 0;
                let walker = document.createTreeWalker(
                    root,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let currentNode;
                while (currentNode = walker.nextNode()) {
                    if (currentNode === node) {
                        return textOffset + Math.min(offset, currentNode.textContent.length);
                    }
                    textOffset += currentNode.textContent.length;
                }
                
                // If we can't find the node, return the total length
                return textOffset;
            } catch (e) {
                console.warn('Error getting caret offset:', e);
                return 0;
            }
        }
        
        // Helper function to restore caret position
        function restoreCaretPosition(root, offset) {
            try {
                let textOffset = 0;
                let walker = document.createTreeWalker(
                    root,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let currentNode;
                while (currentNode = walker.nextNode()) {
                    const nodeLength = currentNode.textContent.length;
                    if (textOffset + nodeLength >= offset) {
                        const range = document.createRange();
                        const selection = window.getSelection();
                        const nodeOffset = Math.min(Math.max(0, offset - textOffset), nodeLength);
                        
                        range.setStart(currentNode, nodeOffset);
                        range.setEnd(currentNode, nodeOffset);
                        selection.removeAllRanges();
                        selection.addRange(range);
                        return true;
                    }
                    textOffset += nodeLength;
                }
                
                // If we can't find the exact position, put cursor at the end of the last text node
                walker = document.createTreeWalker(
                    root,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let lastNode = null;
                while (currentNode = walker.nextNode()) {
                    lastNode = currentNode;
                }
                
                if (lastNode) {
                    const range = document.createRange();
                    const selection = window.getSelection();
                    range.setStart(lastNode, lastNode.textContent.length);
                    range.setEnd(lastNode, lastNode.textContent.length);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    return true;
                }
            } catch (e) {
                console.warn('Error restoring cursor position:', e);
            }
            return false;
        }
        
        // Apply syntax highlighting with debounce
        let highlightTimer;
        function scheduleHighlighting() {
            clearTimeout(highlightTimer);
            highlightTimer = setTimeout(applySyntaxHighlighting, 150);
        }
        
        // Update the input event listener to include syntax highlighting
        editor.addEventListener('input', function() {
            clearTimeout(updateTimer);
            updateTimer = setTimeout(updatePreview, 500);
            
            // Save to localStorage on every change
            saveToStorage();
            
            // Schedule syntax highlighting
            scheduleHighlighting();
        });
        
        // Apply initial syntax highlighting
        setTimeout(() => {
            applySyntaxHighlighting();
            editor.focus();
        }, 100);
    </script>
</body>
</html>